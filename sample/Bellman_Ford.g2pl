
bf(){
    sorce = 0;
    -- Step 1
    D = { if(id(v) == sorce)then{0}else{Inf} | v <- V };
    -- Step 2
    c = NumVertexes(V);
    while(c != 0){
        D = { min(dist(v), dist(u) + weight(e)) | e@(u,v) <- E };
        c = c - 1;
    }
    -- Step 3
    
    if( or[ dist(u) + weight(e) < dist(v) | e@(u,v) <- E] ){
        error;
    }

    return D;
}

f() = { if(dist(v) > dist(v) + weight(e))then{dist(v) + weight(e)}else{Inf} | e@(u,v) <- E }



{-

procedure BellmanFord(list vertices, list edges, vertex source)
   // この実装では、グラフを頂点のリストと辺のリストで表す。
   // そして、各頂点の distance と predecessor 属性が
   // 最短経路を格納するよう変更していく。

   // Step 1: グラフの初期化
   for each vertex v in vertices:
       if v is source then v.distance := 0
       else v.distance := infinity
       v.predecessor := null
   
   // Step 2: 辺の緩和を反復
   for i from 1 to size(vertices) - 1:       
       for each edge uv in edges: // uv は u から v に向かう辺
           u := uv.source
           v := uv.destination             
           if v.distance > u.distance + uv.weight:
               v.distance := u.distance + uv.weight
               v.predecessor := u

   // Step 3: 負の重みの閉路がないかチェック
   for each edge uv in edges:
       u := uv.source
       v := uv.destination
       if u.distance + uv.weight < v.distance:
           error "Graph contains a negative-weight cycle"

-}